/**
 * react-docgen - https://github.com/reactjs/react-docgen
 */

const fs = require('fs');
const { markdown } = require('markdown');
const yaml = require('js-yaml');
const path = require('path');
const Handlebars = require('handlebars');
const _ = require('lodash');
const _s = require('underscore.string');
const reactDocs = require('react-docgen');
const glob = require('glob');
const dependencyTree = require('dependency-tree');
const os = require('os');

const componentTpl = Handlebars.compile(fs.readFileSync(path.resolve(__dirname, 'templates/component.hbs'), 'utf8'));
const srcTpl = path.resolve(__dirname, 'templates/stories.hbs');
const tpl = Handlebars.compile(fs.readFileSync(srcTpl, 'utf8'));
const srcManifest = path.resolve(__dirname, '../manifest.yaml');
const manifest = yaml.safeLoad(fs.readFileSync(srcManifest, 'utf8'));
const storiesDest = path.resolve(__dirname, '../.storybook/stories.js');

/**
 * Given the absolute path to a component, returns the absolute path to the index file
 * that exists there (e.g. index.js / index.ts).
 */
function getComponentEntryFile(componentPath) {
  const files = glob.sync('index*', {
    cwd: componentPath,
    absolute: true,
  });
  if (!files.length) {
    throw new Error(`Unable to locate index file: ${componentPath}`);
  } else if (files.length > 1) {
    throw new Error(`More than one index file located: ${componentPath}`);
  }
  return files[0];
}

/**
 * Given the absolute path to a component, this function will analyze its
 * dependency tree and return an array containing all JS / TS dependencies that
 * exist beneath that component's folder.
 */
function getComponentDependencies(entryFile, dir) {

  const tree = dependencyTree({
    filename: entryFile,
    directory: path.resolve(__dirname, '../'),
    filter: (file, context) => {
      if (file.includes('node_modules')) {
        return false;
      }
      if (file.indexOf(dir) === 0 && ['.js', '.ts'].includes(path.extname(file))) {
        return true;
      }
      return false;
    },
    tsConfig: path.resolve(__dirname, '../tsconfig.json'),
    webpackConfig: path.resolve(__dirname, 'lib/webpack.js'),
  });

  const deps = [];

  function loop(tree) {
    _.each(tree, (v, k) => {
      deps.push(k);
      loop(v);
    });
  }

  loop(tree);

  return deps;

}

/**
 * Given the absolute path to a module containing one or more React components,
 * this function will analyze it using react-docgen and return an object containing
 * descriptions of the component(s).
 * 
 * @param {string} file 
 * @param {bool} throws 
 */
function getModuleInfo(file, throws = false) {
  try {
    const src = fs.readFileSync(file, 'utf8');
    return reactDocs.parse(src);
  } catch(err) {
    if (throws) {
      throw err;
    }
    return null;
  }
}

/**
 * Given a dependency tree array, this function will map the contents so that each
 * entry contains component info generated by react-docgen.
 */
function getComponentInfo(tree = [], document = []) {
  const info =  tree.map(file => ({
    file,
    info: getModuleInfo(file),
  }))
    .map((component) => {
      _.set(component, 'info.formattedDisplayName', _.get(component, 'info.displayName'));
      return component;
    })
    .filter((component) => {
      return document.find((doc) => {
        if (doc.includes('.')) {
          const subname = doc.split('.')[1];
          const match = subname === _.get(component, 'info.displayName');
          if (match) {
            _.set(component, 'info.formattedDisplayName', doc);
            return true;
          } else {
            return false;
          }
        } else {
          return doc === _.get(component, 'info.displayName');
        }
      }) ? true : false;
    })
    .reduce((res, row) => {
      const dup = _.find(res, record => record.info.displayName === row.info.displayName);
      if (dup) {
        return res;
      }
      res.push(row);
      return res;
    }, [])
    .map((component) => {
      component.formattedDisplayName = _.get(component, 'info.formattedDisplayName');
      _.each(component.info.props, (prop) => {
        prop.oneOf = null;
        if (prop.type && prop.type.value && _.isArray(prop.type.value)) {
          prop.oneOf = prop.type.value.map((v) => {
            return v.value
          }).join(', ');
          if (!prop.description) {
            prop.description = `One of: ${prop.oneOf}`;
          } else {
            if (prop.description[prop.description.length - 1] === '.') {
              prop.description += ` One of: ${prop.oneOf}`;
            } else {
              prop.description += `. One of: ${prop.oneOf}`;
            }
          }
        } else if (prop.type && prop.type.value && _.isObject(prop.type.value)) {
          if (!prop.description) {
            prop.description = `
\`\`\`
${JSON.stringify(prop.type.value, null, 4)}
\`\`\`
            `;
          } else {
            prop.description += `

\`\`\`
${JSON.stringify(prop.type.value, null, 4)}
\`\`\`
            `;
          }
        }
        if (prop.description) {
          prop.description = markdown.toHTML(prop.description);
        }
      });
      return component;
    });
  return _.orderBy(info, ['formattedDisplayName'], ['asc']);
}

/**
 * Given an array of components documented via `getComponentInfo`, this function will
 * return a formatted HTML document to be displayed within Storybook.
 */
function getComponentDocs(components = []) {
  if (_.isArray(components)) {
    if (!components.length) {
      return null;
    }
    return components.map(getComponentDocs).join(os.EOL + os.EOL);
  } else {
    return componentTpl(components);
  }
};

const components = manifest.components
  .map(component => {
    _.defaults(component, {
      document: []
    });
    if (!component.document.length) {
      component.document.push(component.name);
    }
    component.category = component.category || 'Components';
    if (component.sandbox) {
      component.category = 'Sandbox';
    }
    component.absolutePath = path.resolve(__dirname, '../src', component.path);
    component.path = path.join('@built/react', component.path);
    component.stories = path.join(component.path, 'stories');
    component.entry = getComponentEntryFile(component.absolutePath);
    component.tree = getComponentDependencies(component.entry, component.absolutePath);
    component.componentInfo = getComponentInfo(component.tree, component.document);
    component.docs = getComponentDocs(component.componentInfo);
    return component;
  });

const storybookComponents = _.chain(components)
  .filter((component) => {
    return _.isBoolean(component.storybook) ? component.storybook : true;
  })
  .orderBy(['name'], ['asc'])
  .value();

// console.log(JSON.stringify(storybookComponents, null, 4));
// process.exit();

const compiled = tpl({
  components: storybookComponents
});

fs.writeFileSync(storiesDest, compiled);
